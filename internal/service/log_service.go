package service

import (
	"context"
	"fmt"
	"log"
	"time"

	"team_bot/internal/model"
	"team_bot/internal/repository/sqlrepo"
)


type LogService struct {
	logRepo *sqlrepo.LogRepository
}


func NewLogService(logRepo *sqlrepo.LogRepository) *LogService {
	return &LogService{
		logRepo: logRepo,
	}
}


func (s *LogService) LogOperation(ctx context.Context, entry model.LogEntry) {

	go func() {

		logCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := s.logRepo.LogOperation(logCtx, entry); err != nil {

			log.Printf("Failed to log operation to database: %v", err)
		}
	}()
}


func (s *LogService) LogUserRegistration(ctx context.Context, userID int64, chatID int64, username string, success bool, errorCode *string) {
	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationUserRegistration,
		Message:       fmt.Sprintf("User registration: %s (ID: %d)", username, userID),
		Context: &model.LogContext{
			UserID:   &userID,
			ChatID:   &chatID,
			Username: &username,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed user registration: %s (ID: %d)", username, userID)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogAdminAction(ctx context.Context, adminUserID int64, adminUsername string, action string, targetUserID *int64, success bool, details *string, errorCode *string) {
	message := fmt.Sprintf("Admin action by %s (ID: %d): %s", adminUsername, adminUserID, action)
	if targetUserID != nil {
		message += fmt.Sprintf(" (target user ID: %d)", *targetUserID)
	}

	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationAdminAction,
		Message:       message,
		Details:       details,
		Context: &model.LogContext{
			UserID:   &adminUserID,
			Username: &adminUsername,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed admin action by %s (ID: %d): %s", adminUsername, adminUserID, action)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogTokenGeneration(ctx context.Context, adminUserID int64, adminUsername string, tokenID int64, expiresAt time.Time, success bool, errorCode *string) {
	details := fmt.Sprintf("Token expires at: %s", expiresAt.Format(time.RFC3339))
	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationTokenGeneration,
		Message:       fmt.Sprintf("Invite token generated by %s (ID: %d), token ID: %d", adminUsername, adminUserID, tokenID),
		Details:       &details,
		Context: &model.LogContext{
			UserID:   &adminUserID,
			Username: &adminUsername,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed to generate invite token by %s (ID: %d)", adminUsername, adminUserID)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogTokenUsage(ctx context.Context, userID int64, username string, chatID int64, tokenID int64, success bool, errorCode *string) {
	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationTokenUsage,
		Message:       fmt.Sprintf("Invite token used by %s (ID: %d), token ID: %d", username, userID, tokenID),
		Context: &model.LogContext{
			UserID:   &userID,
			ChatID:   &chatID,
			Username: &username,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed to use invite token by %s (ID: %d), token ID: %d", username, userID, tokenID)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogBotCommand(ctx context.Context, userID int64, username string, chatID int64, command string, success bool, duration *time.Duration, errorCode *string) {
	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationBotCommand,
		Message:       fmt.Sprintf("Bot command executed by %s (ID: %d): %s", username, userID, command),
		Context: &model.LogContext{
			UserID:   &userID,
			ChatID:   &chatID,
			Username: &username,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if duration != nil {
		durationMs := duration.Milliseconds()
		entry.Duration = &durationMs
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed bot command by %s (ID: %d): %s", username, userID, command)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogUserUpdate(ctx context.Context, userID int64, username string, updateType string, success bool, details *string, errorCode *string) {
	entry := model.LogEntry{
		Level:         model.LogLevelInfo,
		OperationType: model.OperationUserUpdate,
		Message:       fmt.Sprintf("User update by %s (ID: %d): %s", username, userID, updateType),
		Details:       details,
		Context: &model.LogContext{
			UserID:   &userID,
			Username: &username,
		},
		Success:   success,
		ErrorCode: errorCode,
	}

	if !success {
		entry.Level = model.LogLevelError
		entry.Message = fmt.Sprintf("Failed user update by %s (ID: %d): %s", username, userID, updateType)
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) LogError(ctx context.Context, userID *int64, username *string, chatID *int64, message string, details *string, errorCode *string) {
	entry := model.LogEntry{
		Level:         model.LogLevelError,
		OperationType: model.OperationError,
		Message:       message,
		Details:       details,
		Context: &model.LogContext{
			UserID:   userID,
			ChatID:   chatID,
			Username: username,
		},
		Success:   false,
		ErrorCode: errorCode,
	}

	s.LogOperation(ctx, entry)
}


func (s *LogService) GetOperationLogs(ctx context.Context, filters sqlrepo.LogFilters, limit, offset int) ([]*model.OperationLog, error) {
	return s.logRepo.GetOperationLogs(ctx, filters, limit, offset)
}


func (s *LogService) GetOperationLogStats(ctx context.Context, filters sqlrepo.LogFilters) (*sqlrepo.LogStats, error) {
	return s.logRepo.GetOperationLogStats(ctx, filters)
}


func (s *LogService) CleanupOldLogs(ctx context.Context, olderThan time.Duration) (int64, error) {
	return s.logRepo.DeleteOldLogs(ctx, olderThan)
}
